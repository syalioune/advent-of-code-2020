package fr.syalioune.puzzle.treecounting;

import java.util.stream.Stream;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;

public class TreeCounterShould {

  public static final Slope SLOPE = new Slope(3,1);

  @Test
  public void throwsExceptionWhenMapIsNull() {
    // Arrange
    TreeCounter treeCounter = new TreeCounter();

    // Act
    Assertions.assertThrows(IllegalArgumentException.class, () -> treeCounter.count(null, SLOPE));

    // Assert
    // Nothing to be done
  }

  @ParameterizedTest
  @MethodSource("mapWhereSlopeOverflowSource")
  public void throwsExceptionWhenSlopeOverflowTheMap(char[][] map) {
    // Arrange
    TreeCounter treeCounter = new TreeCounter();

    // Act
    Assertions.assertThrows(IllegalArgumentException.class, () -> treeCounter.count(map, SLOPE));

    // Assert
    // Nothing to be done
  }

  @ParameterizedTest
  @MethodSource("validMaps")
  public void returnTheCorrectNumberOfTrees(char[][] map, int expectedNumberOfTrees, Slope slope) {
    // Arrange
    TreeCounter treeCounter = new TreeCounter();

    // Act
    long numberOfTrees = treeCounter.count(map, slope);

    // Assert
    Assertions.assertEquals(expectedNumberOfTrees, numberOfTrees);
  }

  static Stream<char[][]> mapWhereSlopeOverflowSource() {
    char[][] map1 = {
        {'.'},
    };
    char[][] map2 = {
        {'.','#','.','#'},
    };
    return Stream.of(
        map1,
        map2
    );
  }

  static Stream<Arguments> validMaps() {
    char[][] map1 = {
        {'.','.','#', '#', '.'},
        {'#','.','.', '.', '#'}
    };
    char[][] map2 = {
        {'.','.','#', '#', '.'},
        {'#','.','.', '#', '#'}
    };
    char[][] map3 = {
        {'.','.','#', '#', '.', '.', '.', '.'},
        {'#','.','.', '#', '#', '.', '.', '#'},
        {'#','.','.', '#', '#', '#', '#', '#'}
    };
    char[][] map4 = {
        {'.','.','#','#','.','.','.','.','.','.','.','.','.','#','#','.','.','.','.','.','.','.','.','.','#','#','.','.','.','.','.','.','.','.','.','#','#','.','.','.','.','.','.','.','.','.','#','#','.','.','.','.','.','.','.','.','.','#','#','.','.','.','.','.','.','.'},
        {'#','.','.','.','#','.','.','.','#','.','.','#','.','.','.','#','.','.','.','#','.','.','#','.','.','.','#','.','.','.','#','.','.','#','.','.','.','#','.','.','.','#','.','.','#','.','.','.','#','.','.','.','#','.','.','#','.','.','.','#','.','.','.','#','.','.'},
        {'.','#','.','.','.','.','#','.','.','#','.','.','#','.','.','.','.','#','.','.','#','.','.','#','.','.','.','.','#','.','.','#','.','.','#','.','.','.','.','#','.','.','#','.','.','#','.','.','.','.','#','.','.','#','.','.','#','.','.','.','.','#','.','.','#','.'},
        {'.','.','#','.','#','.','.','.','#','.','#','.','.','#','.','#','.','.','.','#','.','#','.','.','#','.','#','.','.','.','#','.','#','.','.','#','.','#','.','.','.','#','.','#','.','.','#','.','#','.','.','.','#','.','#','.','.','#','.','#','.','.','.','#','.','#'},
        {'.','#','.','.','.','#','#','.','.','#','.','.','#','.','.','.','#','#','.','.','#','.','.','#','.','.','.','#','#','.','.','#','.','.','#','.','.','.','#','#','.','.','#','.','.','#','.','.','.','#','#','.','.','#','.','.','#','.','.','.','#','#','.','.','#','.'},
        {'.','.','#','.','#','#','.','.','.','.','.','.','.','#','.','#','#','.','.','.','.','.','.','.','#','.','#','#','.','.','.','.','.','.','.','#','.','#','#','.','.','.','.','.','.','.','#','.','#','#','.','.','.','.','.','.','.','#','.','#','#','.','.','.','.','.'},
        {'.','#','.','#','.','#','.','.','.','.','#','.','#','.','#','.','#','.','.','.','.','#','.','#','.','#','.','#','.','.','.','.','#','.','#','.','#','.','#','.','.','.','.','#','.','#','.','#','.','#','.','.','.','.','#','.','#','.','#','.','#','.','.','.','.','#'},
        {'.','#','.','.','.','.','.','.','.','.','#','.','#','.','.','.','.','.','.','.','.','#','.','#','.','.','.','.','.','.','.','.','#','.','#','.','.','.','.','.','.','.','.','#','.','#','.','.','.','.','.','.','.','.','#','.','#','.','.','.','.','.','.','.','.','#'},
        {'#','.','#','#','.','.','.','#','.','.','.','#','.','#','#','.','.','.','#','.','.','.','#','.','#','#','.','.','.','#','.','.','.','#','.','#','#','.','.','.','#','.','.','.','#','.','#','#','.','.','.','#','.','.','.','#','.','#','#','.','.','.','#','.','.','.'},
        {'#','.','.','.','#','#','.','.','.','.','#','#','.','.','.','#','#','.','.','.','.','#','#','.','.','.','#','#','.','.','.','.','#','#','.','.','.','#','#','.','.','.','.','#','#','.','.','.','#','#','.','.','.','.','#','#','.','.','.','#','#','.','.','.','.','#'},
        {'.','#','.','.','#','.','.','.','#','.','#','.','#','.','.','#','.','.','.','#','.','#','.','#','.','.','#','.','.','.','#','.','#','.','#','.','.','#','.','.','.','#','.','#','.','#','.','.','#','.','.','.','#','.','#','.','#','.','.','#','.','.','.','#','.','#'}
    };
    char[][] map5 = {
        {'.','.','#', '#', '.'},
        {'#','.','.', '#', '#'},
        {'#','#','.', '#', '#'}
    };
    return Stream.of(
        Arguments.arguments(map1,0, SLOPE),
        Arguments.arguments(map2,1, SLOPE),
        Arguments.arguments(map3,2, SLOPE),
        Arguments.arguments(map4,2, new Slope(1,1)),
        Arguments.arguments(map4,7, SLOPE),
        Arguments.arguments(map4,3, new Slope(5,1)),
        Arguments.arguments(map4,4, new Slope(7,1)),
        Arguments.arguments(map4,2, new Slope(1,2)),
        Arguments.arguments(map5,2, SLOPE)
    );
  }

}
